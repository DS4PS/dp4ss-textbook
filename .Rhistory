print(y)
```
<br>
Often, **logical** values simply indicate "yes" or "no" for your criteria:
```{r}
character <- c("Raskolnikov", "Marmeladov", "Razumikhin")
criminal <- c(TRUE, FALSE, FALSE)
data.frame(character,
criminal)        # Create data frame of characters and crime status
```
<br>
Typically, **logical** values result from conditional statements on:
* Variables within a dataset, using `data$variable` or `data[i, j]` format
* Independent **vectors** created using `c()`
<br>
Let's read in the first 100 rows of [Atlanta, Georgia poverty by census tract, 2016](https://opendata.atlantaregional.com/datasets/poverty-2016):
```{r}
library(readr)
library(dplyr)
url <- paste0("https://opendata.arcgis.com",
"/datasets/73c0eca114c440208",
"b268bf9431e428c_240.csv")        # Atlanta's open data portal URL
atl <- read_csv(url)[1:100, c(3:5, 9)] %>%      # Read 100 rows, 4 variables
arrange(County, Area_Name)                    # Arrange by county, tract
head(atl)                                       # Print first 6 observations
```
<br>
Here we use logical operator `>` to create a conditional statement:
*Which census tracts have populations larger than 7,000?*
```{r}
atl$Total_Population > 7000
```
The result is a **vector** of logical values, or `TRUE` and `FALSE`.
<br>
Here's a more complex conditional statement with two criteria using `&`:
*Which tracts have more than 7,000 residents but less the 2,000 in poverty?*
```{r}
atl$Total_Population > 7000 & atl$Pop_below_poverty < 2000
```
<br>
<br>
### Logical Values: Under the Hood
Under the hood, **logical** statements are represented in binary. That is:
* `TRUE` equals "1"
* `FALSE` equals "0"
<br>
We can prove this in a number of ways, like converting them to numeric values:
```{r}
as.numeric(TRUE)            # Coerce logicals to class "numeric"
as.numeric(FALSE)           # Coerce logicals to class "numeric"
```
<br>
Or we can simply use a conditional statement with logical operator `==`:
```{r}
TRUE == 1
FALSE == 0
```
<br>
Or we can use arithmetic functions like `sum()`:
```{r}
z <- c(TRUE, TRUE, TRUE)
sum(z)
```
<br>
**Conclusions:** Since **logical** values are numeric, this opens a world of possibilities for summarizing datasets and vectors that meet specified criteria, and we'll check some out in the next section.
<br>
<br>
## Summarizing Logical Vectors with Arithmetic
Because **logical** vectors are really just ones and zeros, we can determine:
* Matching criteria with function `sum()`
* Non-matching criteria with functions `length()` and `sum()`
* Proportionality, percentage, and/or probability with `mean()`
<br>
**Total All TRUE Values:** Use function `sum()` and a conditional statement:
*Of our 100 tracts, how many have more than 1,000 residents in poverty?*
```{r}
atl$Pop_below_poverty > 1000                # Conditional statement
impov <- atl$Pop_below_poverty > 1000       # Store vector: "impov"
sum(impov)                                  # Summing all TRUE values
```
<br>
**Total All FALSE Instances:** We can do this with a little arithmetic:
* Determine total number of elements with function `length()`
* Use `-` to subtract `TRUE` instances calculated with `sum()`
*Of our 100 tracts, how many do not have more than 1,000 residents in poverty?*
```{r}
length(impov) - sum(impov)                  # Total elements - TRUE elements
```
<br>
**Percent of TRUE Values:** Use `mean()` to calculate the proportion of `TRUE` values:
*Of our 100 tracts, what is the proportion with more than 1,000 residents in poverty?*
```{r}
mean(impov)                                 # Average of all ones and zeros
```
<br>
<br>
<div class="quiz">
<h3>
**Your Turn:** Summarizing Logical Vectors
</h3>
**Instructions:** Use the dataset `economics` from package *ggplot2*.
1. Use `sum()` to calculate which months have:
* More then 3 M unemployed residents (`unemploy > 3000`)
2. Use `length() - sum()` to calculate which months do not have:
* Less than 3 M unemployed residents (`unemploy < 3000`)
3. Use `mean()` to calculate the proportion of months that have:
* Greater than or equal to 3 M residents (`unemploy >= 3000`)
<br>
<br>
<br>
</div>
```{r ex="practice-01", type="sample-code", tut=TRUE}
library(ggplot2)      # Load ggplot2
head(economics, 3)    # Print first 3 rows
# Total months where unemployed > 3000 K
sum(economics$___ > ___)
# Total months where unemployed not > 3000 K
___(economics$___) - sum(___$unemploy > 3000)
# Percent of months where unemployed 3000 K or more
___(___$unemploy >= 3000)
```
<br>
<br>
## Creating Factors: Categorizing Logical Vectors
When you create **logical vectors** from conditional statements, we can:
* Categorize `TRUE` and `FALSE` values
* Create categorical variables, or **factors**
* More clearly summarize our data by specifying *how* they satisfy conditions
<br>
### Determining Which Rows Match Your Condition(s)
You can create a new **vector** of row numbers that are `TRUE` using `which()`:
*Which census tracts have more than 1,000 residents in poverty?*
```{r}
impov <- atl$Pop_below_poverty > 1000   # Store logical vector: `impov`
which(impov)                            # Determine row number of TRUE values
```
<br>
### Indexing & Labeling Rows that Match Your Condition(s)
By assigning which rows match your conditional statement (using `which()`):
1. You can create an index of rows and assign them to an object
2. Then, you can operate *only on the rows that satisfy your conditions*
<br>
**Indexing Matching Rows:** Use assignment with `<-` to create an index of rows:
```{r}
impov <- atl$Pop_below_poverty > 1000   # Assign logical vector: `impov`
index <- which(impov)                   # Assign row numbers: "index"
print(index)                            # Print row numbers that are TRUE
```
<br>
**Filter Matching Rows:** Using row numbers assigned to object `index`, we can **filter**:
* Rows which return `FALSE` vis-à-vis our conditions
* Rows which return `TRUE` vis-à-vis our conditions
```{r}
atl[index, ]            # Keep rows with TRUE (more than 1K in poverty)
atl[-index, ]           # Remove rows with TRUE (less than 1K in poverty)
```
<br>
**Label Matching Rows:** We can categorize matching rows by assigning labels to them.
1. First, add a variable of missing (`NA`) values: i.e. `dataframe$new_variable <- NA`
2. Next, assign a text string of class "character" to matching rows (`TRUE`)
3. Lastly, assign a text string to non-matching rows (`FALSE`)
```{r}
atl$poverty_threshold <- NA                   # Initialize variable of all NAs
atl[index, "poverty_threshold"] <- "Over"     # Assign label for rows with TRUE
atl[-index, "poverty_threshold"] <- "Under"   # Assign label for rows with FALSE
head(atl, 10)
```
<br>
<br>
## Describing Vectors of Class "Character"
R *describes* quantitative (**numeric**) and qualitative (**character** or **factor**) data differently.
Notably, it *describes* **character** data and **factor** (categorical) data differently.
<br>
<br>
### Exploratory Analytic & Descriptive Functions
You can explore and summarize **character** vectors with various exploratory functions.
<br>
**Structure:** Function `str()` prints an object's class, dimensions, and first observations.
```{r}
str(atl$poverty_threshold)
```
<br>
**Summary:** Function `summary()` also prints the class, mode, and length of a **character** vector.
```{r}
summary(atl$poverty_threshold)
```
<br>
**Value Frequency:** Function `table()` tallies the frequency of each **character** value.
```{r}
table(atl$poverty_threshold)
```
table(atl$poverty_threshold)
tmp <- table(atl$poverty_threshold)
prop.table(tmp)
tbl <- prop.table(atl$poverty_threshold)
tbl <- table(atl$poverty_threshold)
prop.table(tbl)
atl$poverty_threshold <- NA                   # Initialize variable of all NAs
atl$poverty_threshold
atl
ifelse(test = atl$Pop_below_poverty > 1000, yes = "Over", no = "Under")
label <- ifelse(test = atl$Pop_below_poverty > 1000,
yes = "Over",
no = "Under")
atl$poverty_threshold <- NA                   # Initialize variable of all NAs
label <- ifelse(test = atl$Pop_below_poverty > 1000,
yes = "Over",
no = "Under")
atl$poverty_threshold <- label
head(atl, 10)
hist(atl$Total_Population)
which(atl$Total_Population < 3000)
hist(atl$Total_Population)
which(atl$Total_Population >= 3000 & atl$Total_Population < 6000)
which(atl$Total_Population < 3000)
which(atl$Total_Population >= 3000 & atl$Total_Population < 6000)
atl$population_size <- NA                             # Initialize variable of all NAs
sml <- which(atl$Total_Population < 3000)
med <- which(atl$Total_Population >= 3000 & atl$Total_Population < 6000)
lrg <- which(atl$Total_Population >= 6000 & atl$Total_Population < 10000)
wow <- which(atl$Total_Population >= 10000)
atl[sml, "population_size"] <- "Small"
atl[med, "population_size"] <- "Medium"
atl[lrg, "population_size"] <- "Large"
atl[wow, "population_size"] <- "Massive"
atl
atl[ , "poverty_threshold"]
atl[ , -"poverty_threshold"]
-atl[ , "poverty_threshold"]
names(atl)
atl[ , -5]
atl$population_size <- NA                             # Initialize variable of all NAs
sml <- which(atl$Total_Population < 3000)
med <- which(atl$Total_Population >= 3000 & atl$Total_Population < 6000)
lrg <- which(atl$Total_Population >= 6000 & atl$Total_Population < 10000)
wow <- which(atl$Total_Population >= 10000)
atl[sml, "population_size"] <- "Small"
atl[med, "population_size"] <- "Medium"
atl[lrg, "population_size"] <- "Large"
atl[wow, "population_size"] <- "Massive"
head(atl, 10)
atl <- atl[ , -5]
atl$population_size <- NA                             # Initialize variable of all NAs
sml <- which(atl$Total_Population < 3000)
med <- which(atl$Total_Population >= 3000 & atl$Total_Population < 6000)
lrg <- which(atl$Total_Population >= 6000 & atl$Total_Population < 10000)
wow <- which(atl$Total_Population >= 10000)
atl[sml, "population_size"] <- "Small"
atl[med, "population_size"] <- "Medium"
atl[lrg, "population_size"] <- "Large"
atl[wow, "population_size"] <- "Massive"
head(atl, 10)
nchar("https://data.cityofnewyork.us/api/views/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")
78/2
nchar("https://data.cityofnewyork.us/api/views/")
nchar("https://data.cityofnewyork.us/api/views")
taxi <- read_csv(url)
names(taxi)
url <- paste0("https://data.cityofnewyork.us/api/views",
"/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")    # Assign URL
taxi <- read_csv(url)                                       # Read in, assign: "taxi"
taxi
library(lubridate)
year(taxi$`Last Date Updated`)
mdy(taxi$`Last Date Updated`)
which( mdy( taxi$`Last Date Updated` < ymd("2017-01-01")))
ymd("2017-01-01")
class(ymd("2017-01-01"))
which( year( mdy( taxi$`Last Date Updated` ) < 2016))
year( mdy( taxi$`Last Date Updated` ))
which( year( mdy( taxi$`Last Date Updated` )) < 2016)
which( year( mdy( taxi$`Last Date Updated` )) < 2019)
which( year( mdy( taxi$`Expiration Date`)) < 2019)
which( year( mdy( taxi$`Expiration Date`)) == 2019)
which( month( mdy( taxi$`Expiration Date`)) == "December")
month( mdy( taxi$`Expiration Date`))
which( month( mdy( taxi$`Expiration Date`)) == 4)
taxi$`Expiration Date` <- mdy(taxi$`Expiration Date`)
taxi$`Expiration Date` <- mdy(taxi$`Expiration Date`)
taxi
View(taxi)
url <- paste0("https://data.cityofnewyork.us/api/views",
"/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")    # Assign URL
taxi <- read_csv(url)                                       # Read in, assign: "taxi"
taxi$`Expiration Date` <- mdy(taxi$`Expiration Date`)
library(dplyr)
names(tax)
names(taxi)
taxi$`Last Time Updated`[1:5]
taxi <- read_csv(url)[1000, ] %>%
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))
taxi <- read_csv(url)[1000, ] %>%
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))
taxi
taxi <- read_csv(url)[1000, ] %>%                           # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
library(readr)
library(dplyr)
library(lubridate)
url <- paste0("https://data.cityofnewyork.us/api/views",
"/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")    # Assign URL
taxi <- read_csv(url)[1000, ] %>%                           # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
library(readr)
library(dplyr)
library(lubridate)
url <- paste0("https://data.cityofnewyork.us/api/views",
"/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")    # Assign URL
taxi <- read_csv(url)[1000, ] %>%                           # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
library(lubridate)
year(taxi$`Expiration Date`) == 2021
year(taxi$`Expiration Date`)
taxi <- read_csv(url)[1000, ] %>%                           # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
taxi <- read_csv(url)[1000, ]
taxi <- read_csv(url) %>%                                   # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
year(taxi$`Expiration Date`)
expires_2021 <- year(taxi$`Expiration Date`) == 2021
expires_2021
sum(expires_2021)
mean(expires_2021)
library(lubridate)
expire_21 <- year(taxi$`Expiration Date`) == 2021     # TRUE if expires in 2021
sum(expire_21)                                        # Sum of 2021 expirations
mean(expire_21)                                       # Percent of 2021 expirations
palindrome <- taxi$`Expiration Date` == "2020-02-02"
palindrome
which(palindrome)
index <- which( taxi$`Expiration Date` == "2020-02-02")
taxi[index, ]
index <- which( taxi$`Expiration Date` == "2020-02-02")   # Index rows where TRUE
palindrome <- taxi[index, ]                               # Filter indexed rows
head(palindrome)
unique(taxi$Type)
unique(taxi$Name)
grepl(pattern = "^Singh", x = taxi$Name)
surname_match <- grepl(pattern = "^Singh", x = taxi$Name)
sum(surname_match)
surname_match <- grepl(pattern = "^Singh",
x = taxi$Name)
sum(surname_match)
surname_match <- grepl(pattern = "^Singh.*",
x = taxi$Name)
sum(surname_match)
surname_match <- grepl(pattern = "^Singh.*",
x = taxi$Name)
sum(surname_match)
mean(surname_match)
surname_match <- grepl(pattern = "^Singh.*",
x = taxi$Name)
sum(surname_match)
surname_match <- grepl(pattern = "^SINGH.*",
x = taxi$Name)
sum(surname_match)
mean(surname_match)
surname_match <- grepl(pattern = "^SINGH.*",
x = taxi$Name)
sum(surname_match)
mean(surname_match)
head(surname_match)
head(surname_match, 15)                         # Return first 15 TRUE or FALSE
surname_match <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
head(surname_match, 10)                         # Return first 10 TRUE or FALSE
sum(surname_match)                              # Total TRUE
mean(surname_match)                             # Percent TRUE
is.na(taxi$Name)
sum(is.na(taxi$Name))
sum(is.na(taxi$`Last Date Updated`))
sum(is.na(taxi$`Last Time Updated`))
surname_match <- grepl(pattern = "^PATEL.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
head(surname_match, 10)                         # Return first 10 TRUE or FALSE
sum(surname_match)                              # Total TRUE
mean(surname_match)                             # Percent TRUE
index <- grepl(pattern = "^PATEL.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
names(taxi)
is.na(taxi$Name)
missing <- is.na(taxi$Name)             # Detect, store missing values
missing <- is.na(taxi$Name)             # Detect, store missing values
sum(missing)
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
incomplete <- taxi[-index, "Name"]      # Remove all matching in "Name"
missing <- is.na(taxi$Name)             # Detect, store missing values
sum(missing)
incomplete
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
incomplete <- taxi[-index, "Name"]      # Remove all matching in "Name"
missing <- is.na(incomplete$Name)       # Detect, store missing values
sum(missing)
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
names(taxi)
incomplete <- taxi[-index, 2]           # Remove all matching in "Name"
missing <- is.na(incomplete$Name)       # Detect, store missing values
sum(missing)
incomplete
incomplete
incomplete <- taxi[-index, 2]           # Remove all matching in "Name"
taxi[-index, 2]
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
taxi[-index, "Name"] <- NA              # Remove all matching in "Name"
missing <- is.na(incomplete$Name)       # Detect, store missing values
missing
sum(missing)
missing <- is.na(tax$Name)              # Detect, store missing values
missing <- is.na(tax$Name)              # Detect, store missing values
missing <- is.na(taxi$Name)             # Detect, store missing values
sum(missing)
## Logical Vectors & Non-Numeric Conditionals
**Logical** vectors result from any conditional statement, even if not quantitative.
Below are a few use cases for **logical** values based on non-numeric conditions.
These data come from [New York City's medallian-authorized cab drivers](https://data.cityofnewyork.us/Transportation/Medallion-Drivers-Active/jb3k-j3gp/data).
```{r cache=T}
library(readr)
library(dplyr)
library(lubridate)
url <- paste0("https://data.cityofnewyork.us/api/views",
"/jb3k-j3gp/rows.csv?accessType=DOWNLOAD")    # Assign URL
taxi <- read_csv(url) %>%                                   # Read in 1,000 rows
mutate(`Expiration Date` = mdy(`Expiration Date`),
`Last Date Updated` = mdy(`Last Date Updated`),
`Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times
```
<br>
**Date-Based Conditions:** Let's extract medallians expiring on [palindrome](https://en.wikipedia.org/wiki/Palindrome) 2020-02-02:
```{r}
index <- which( taxi$`Expiration Date` == "2020-02-02")   # Index rows where TRUE
palindrome <- taxi[index, ]                               # Filter by indexed rows
head(palindrome)
```
<br>
**Date Unit-Based Conditions:** Here, we use function `year()` from package *lubridate*:
* Function `year()` extracts the year from date objects
* Our logical statement returns `TRUE` if `year()` returns "2021"
* Function `sum()` is used to tally all medallians expiring in 2021
* Function `mean()` is used to calculate the percent of 2021 expirations
```{r}
library(lubridate)
expire_21 <- year(taxi$`Expiration Date`) == 2021     # TRUE if expires in 2021
sum(expire_21)                                        # Sum of 2021 expirations
mean(expire_21)                                       # Percent of 2021 expirations
```
<br>
**Text-Based Conditions**: Use core R function `grepl()` for conditional pattern-matching.
* The 'l' in 'grepl()' stands for "logical" - it's designed to output **logical** values!
* Here, we'll search for all records beginning with common Indian surname "Singh"
* The pattern matching method is called "regular expressions"
- `^` indicates that the pattern is at the beginning of the string
- `.` indicates "any character" and `*` indicates "any number of times"
- Therefore, we only retrieve records that begin with `Singh`
```{r}
surname_match <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
head(surname_match, 10)                         # Return first 10 TRUE or FALSE
sum(surname_match)                              # Total TRUE
mean(surname_match)                             # Percent TRUE
```
<br>
Compare these results to the most common Indian surname in London: "Patel". Wow!
```{r}
surname_match <- grepl(pattern = "^PATEL.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
head(surname_match, 10)                         # Return first 10 TRUE or FALSE
sum(surname_match)                              # Total TRUE
mean(surname_match)                             # Percent TRUE
```
<br>
**Conditions with Missing Values:** It's very common to condition on missing values (`NA`).
* Function `is.na()` returns a **logical** vector of `TRUE` or `FALSE`
* This is similar to any `is.*()` function, all of which return **logical** values
* Since these data have no missing data, remove all drivers with surname "Singh"
```{r}
index <- grepl(pattern = "^SINGH.*",    # Regular expressions pattern
x = taxi$Name)           # Specify dataset and variable
taxi[index, "Name"] <- NA               # Remove all matching in "Name"
missing <- is.na(taxi$Name)             # Detect, store missing values
sum(missing)
```
complete.cases(taxi)
complete.cases(taxi)[100]
complete.cases(taxi)[100]
complete.cases(taxi)[100, ]
complete.cases(taxi[100, ])
complete.cases(taxi[100, ])
taxi[100, ]
taxi[100, ]
class(taxi)
complete.cases(taxi[1:100, ])
sum(complete.cases(taxi[1:100, ]))
