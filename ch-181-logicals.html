<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>ch-181-logicals.utf8.md</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="textbook.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DATA SCIENCE I</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://ds4ps.org/cpp-526-fall-2019/textbook/">
    <span class="fa fa-sun fa-2x"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>

<div id="TOC">
<ul>
<li><a href="#describing-data-with-logical-variables"><span class="toc-section-number">1</span> Describing Data with Logical Variables</a><ul>
<li><a href="#on-logical-variables"><span class="toc-section-number">1.1</span> On Logical Variables</a></li>
<li><a href="#summarizing-logical-vectors-with-arithmetic"><span class="toc-section-number">1.2</span> Summarizing Logical Vectors with Arithmetic</a></li>
<li><a href="#labels-categorizing-logical-vectors"><span class="toc-section-number">1.3</span> Labels: Categorizing Logical Vectors</a></li>
<li><a href="#logical-vectors-non-numeric-conditionals"><span class="toc-section-number">1.4</span> Logical Vectors &amp; Non-Numeric Conditionals</a></li>
<li><a href="#further-resources"><span class="toc-section-number">1.5</span> Further Resources</a></li>
</ul></li>
</ul>
</div>

<script src="https://cdn.datacamp.com/datacamp-light-latest.min.js"></script>
<div id="describing-data-with-logical-variables" class="section level1">
<h1><span class="header-section-number">1</span> Describing Data with Logical Variables</h1>
<p><br></p>
<p><img src="https://media3.giphy.com/media/iXTrbbYMQBCMM/giphy.gif?cid=790b761106a88e0f92148d9d48b65a1b096928d1be508103&rid=giphy.gif" width="100%" style="display: block; margin: auto;" /></p>
<p><br>
<br></p>
<div class="tip">
<h2 id="a-motivating-introduction"><span class="header-section-number">1</span> A Motivating Introduction</h2>
<p>Getting the basics down for class “logical” vectors and variables is fundamental to introductory fluency in R. We use logical output for filtering, labeling, control structures (i.e. programming), and many other use cases. In particular, we use logical values in exploratory data analysis, i.e. learning about new data and the stories they tell.</p>
<p><br></p>
<p>We’ll use the basic techniques described herein in many future chapters - sometimes in passing or otherwise very invasively, and for that reason alone, we hope you delve into logical data with earnest. Even a rudimentary understanding of logical vectors and variables means that an inchoate understanding of these concepts will ensure future data exploration and manipulation will be off the chain. Guaranteed.</p>
<p><br></p>
<h2 id="key-concepts"><span class="header-section-number">1</span> Key Concepts</h2>
<p>In this chapter, we’ll take a look at the following:</p>
<ul>
<li>Refresher: On Class “Logical” Data</li>
<li>Logical Values “Under the Hood”</li>
<li>Logical Vectors &amp; Conditional Statements</li>
<li>Summarizing Logical Vectors with Arithmetic
<ul>
<li>Total Occurences</li>
<li>Percentages, Proportions, and Probabilities</li>
</ul></li>
<li>Indexing Logical Vectors by Row</li>
<li>Conditional Labeling &amp; Filtering</li>
<li>Use Cases for Non-Numeric Condition Statements
<ul>
<li>Date-Based Conditions</li>
<li>Date Unit-Based Conditions</li>
<li>Text- &amp; Pattern-Based Conditions</li>
<li>Conditions with Missing Values</li>
<li>Conditions with Incomplete Records</li>
</ul></li>
</ul>
<h2 id="new-packages"><span class="header-section-number">1</span> New Packages</h2>
<p>This chapter uses <a href="https://lubridate.tidyverse.org/">package <em>lubridate</em></a> (but just a little).</p>
<h2 id="key-takeaways"><span class="header-section-number">1</span> Key Takeaways</h2>
<p>Too long; didn’t read? Here’s what you need to know:</p>
<ul>
<li>Class “logical” variables are vectors of <code>TRUE</code> and <code>FALSE</code> values</li>
<li>“Under the hood”, <code>TRUE</code> is just “1”, and <code>FALSE</code> is just “2”
<ul>
<li>Ergo, we can use <code>sum()</code> and <code>mean()</code> to find total and percent <code>TRUE</code></li>
</ul></li>
<li>Use function <code>which()</code> to determine which rows are, in fact, <code>TRUE</code>
<ul>
<li>Assign row numbers output from <code>which()</code> to use them as an index</li>
<li>In this sense, the format <code>dataset[index, ]</code> returns all <code>TRUE</code> rows</li>
<li>Use indices to label <code>TRUE</code> and <code>FALSE</code> variables differently</li>
<li>More easily, use function <code>ifelse()</code> to streamline labeling</li>
</ul></li>
<li>There are many non-numeric use cases that return logical values
<ul>
<li>Function <code>grepl()</code> returns <code>TRUE</code> if it detects a pattern in text</li>
<li>Function <code>is.na()</code> returns <code>TRUE</code> if a value is missing (<code>NA</code>)</li>
<li>Function <code>complete.cases()</code> returnes <code>TRUE</code> if a row has 1+ <code>NA</code> values</li>
</ul></li>
</ul>
<p>We want our analyses to be off the chain, however. So we recommend you read this in earnest.</p>
<p><br>
<br>
<br></p>
</div>
<p><br>
<br></p>
<div id="on-logical-variables" class="section level2">
<h2><span class="header-section-number">1.1</span> On Logical Variables</h2>
<p>Class <strong>logical</strong> variables are typically comprised of one of two values: <code>TRUE</code> or <code>FALSE</code>.</p>
<p><br>
<br></p>
<div id="quick-refresher-on-class-logical" class="section level3">
<h3><span class="header-section-number">1.1.1</span> Quick Refresher on Class Logical</h3>
<p>We can create <strong>logical</strong> variables manually. Determine their class with function <code>class()</code>:</p>
<pre class="r"><code>x &lt;- TRUE

class(x)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p><br></p>
<p>While not considered a best practice, we can use <code>T</code> and <code>F</code> as abbreviated values:</p>
<pre class="r"><code>y &lt;- F

print(y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p><br></p>
<p>Often, <strong>logical</strong> values simply indicate “yes” or “no” for your criteria:</p>
<pre class="r"><code>character &lt;- c(&quot;Raskolnikov&quot;, &quot;Marmeladov&quot;, &quot;Razumikhin&quot;)
criminal &lt;- c(TRUE, FALSE, FALSE)

data.frame(character,
           criminal)        # Create data frame of characters and crime status</code></pre>
<pre><code>##     character criminal
## 1 Raskolnikov     TRUE
## 2  Marmeladov    FALSE
## 3  Razumikhin    FALSE</code></pre>
<p><br></p>
<p>Typically, <strong>logical</strong> values result from conditional statements on:</p>
<ul>
<li>Variables within a dataset, using <code>data$variable</code> or <code>data[i, j]</code> format</li>
<li>Independent <strong>vectors</strong> created using <code>c()</code></li>
</ul>
<p><br></p>
<p>Let’s read in the first 100 rows of <a href="https://opendata.atlantaregional.com/datasets/poverty-2016">Atlanta, Georgia poverty by census tract, 2016</a>:</p>
<pre class="r"><code>library(readr)
library(dplyr)

url &lt;- paste0(&quot;https://opendata.arcgis.com&quot;,
              &quot;/datasets/73c0eca114c440208&quot;,
              &quot;b268bf9431e428c_240.csv&quot;)        # Atlanta&#39;s open data portal URL

atl &lt;- read_csv(url)[1:100, c(3:5, 9)] %&gt;%      # Read 100 rows, 4 variables
  arrange(County, Area_Name)                    # Arrange by county, tract

head(atl)                                       # Print first 6 observations</code></pre>
<pre><code>## # A tibble: 6 x 4
##   County Area_Name                        Total_Population Pop_below_pover~
##    &lt;dbl&gt; &lt;chr&gt;                                       &lt;dbl&gt;            &lt;dbl&gt;
## 1  13013 Census Tract 1801.04, Barrow Co~             2032              544
## 2  13013 Census Tract 1801.06, Barrow Co~             2773              462
## 3  13013 Census Tract 1803.02, Barrow Co~             5434              774
## 4  13013 Census Tract 1805.03, Barrow Co~             4960              348
## 5  13015 Census Tract 9603, Bartow County             6714              893
## 6  13015 Census Tract 9604.01, Bartow Co~            10043              962</code></pre>
<p><br></p>
<p>Here we use logical operator <code>&gt;</code> to create a conditional statement:</p>
<p><em>Which census tracts have populations larger than 7,000?</em></p>
<pre class="r"><code>atl$Total_Population &gt; 7000</code></pre>
<pre><code>##   [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE
##  [12]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
##  [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
##  [45]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE
##  [56] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE
##  [67] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE
##  [78] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
##  [89] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
## [100] FALSE</code></pre>
<p>The result is a <strong>vector</strong> of logical values, or <code>TRUE</code> and <code>FALSE</code>.</p>
<p><br></p>
<p>Here’s a more complex conditional statement with two criteria using <code>&amp;</code>:</p>
<p><em>Which tracts have more than 7,000 residents but less the 2,000 in poverty?</em></p>
<pre class="r"><code>atl$Total_Population &gt; 7000 &amp; atl$Pop_below_poverty &lt; 2000</code></pre>
<pre><code>##   [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE
##  [12]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
##  [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
##  [45]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE
##  [56] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
##  [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE
##  [78] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE
##  [89] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE
## [100] FALSE</code></pre>
<p><br>
<br></p>
</div>
<div id="logical-values-under-the-hood" class="section level3">
<h3><span class="header-section-number">1.1.2</span> Logical Values: Under the Hood</h3>
<p>Under the hood, <strong>logical</strong> statements are represented in binary. That is:</p>
<ul>
<li><code>TRUE</code> equals “1”</li>
<li><code>FALSE</code> equals “0”</li>
</ul>
<p><br></p>
<p>We can prove this in a number of ways, like converting them to numeric values:</p>
<pre class="r"><code>as.numeric(TRUE)            # Coerce logicals to class &quot;numeric&quot;</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>as.numeric(FALSE)           # Coerce logicals to class &quot;numeric&quot;</code></pre>
<pre><code>## [1] 0</code></pre>
<p><br></p>
<p>Or we can simply use a conditional statement with logical operator <code>==</code>:</p>
<pre class="r"><code>TRUE == 1</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>FALSE == 0</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p><br></p>
<p>Or we can use arithmetic functions like <code>sum()</code>:</p>
<pre class="r"><code>z &lt;- c(TRUE, TRUE, TRUE)
sum(z)</code></pre>
<pre><code>## [1] 3</code></pre>
<p><br></p>
<p><strong>Conclusions:</strong> Since <strong>logical</strong> values are numeric, this opens a world of possibilities for summarizing datasets and vectors that meet specified criteria, and we’ll check some out in the next section.</p>
<p><br>
<br></p>
</div>
</div>
<div id="summarizing-logical-vectors-with-arithmetic" class="section level2">
<h2><span class="header-section-number">1.2</span> Summarizing Logical Vectors with Arithmetic</h2>
<p>Because <strong>logical</strong> vectors are really just ones and zeros, we can determine:</p>
<ul>
<li>Matching criteria with function <code>sum()</code></li>
<li>Non-matching criteria with functions <code>length()</code> and <code>sum()</code></li>
<li>Proportionality, percentage, and/or probability with <code>mean()</code></li>
</ul>
<p><br></p>
<p><strong>Total All TRUE Instances:</strong> Use function <code>sum()</code> and a conditional statement:</p>
<p><em>Of our 100 tracts, how many have more than 1,000 residents in poverty?</em></p>
<pre class="r"><code>atl$Pop_below_poverty &gt; 1000                # Conditional statement</code></pre>
<pre><code>##   [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE
##  [12]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [23] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
##  [34] FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE
##  [45]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
##  [56] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
##  [67]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE
##  [78] FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE
##  [89]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
## [100]  TRUE</code></pre>
<pre class="r"><code>impov &lt;- atl$Pop_below_poverty &gt; 1000       # Store vector: &quot;impov&quot;

sum(impov)                                  # Summing all TRUE values</code></pre>
<pre><code>## [1] 43</code></pre>
<p><br></p>
<p><strong>Total All FALSE Instances:</strong> We can do this with a little arithmetic:</p>
<ul>
<li>Determine total number of elements with function <code>length()</code></li>
<li>Use <code>-</code> to subtract <code>TRUE</code> instances calculated with <code>sum()</code></li>
</ul>
<p><em>Of our 100 tracts, how many do not have more than 1,000 residents in poverty?</em></p>
<pre class="r"><code>length(impov) - sum(impov)                  # Total elements - TRUE elements</code></pre>
<pre><code>## [1] 57</code></pre>
<p><br></p>
<p><strong>Percent of TRUE Instances:</strong> Use <code>mean()</code> to calculate the proportion of <code>TRUE</code> values:</p>
<p><em>Of our 100 tracts, what is the proportion with more than 1,000 residents in poverty?</em></p>
<pre class="r"><code>mean(impov)                                 # Average of all ones and zeros</code></pre>
<pre><code>## [1] 0.43</code></pre>
<p><br>
<br></p>
<div class="quiz">
<h3>
<p><strong>Your Turn:</strong> Summarizing Logical Vectors</p>
</h3>
<p><strong>Instructions:</strong> Use the dataset <code>economics</code> from package <em>ggplot2</em>.</p>
<ol style="list-style-type: decimal">
<li><p>Use <code>sum()</code> to calculate which months have:</p>
<ul>
<li>More then 3 M unemployed residents (<code>unemploy &gt; 3000</code>)</li>
</ul></li>
<li><p>Use <code>length() - sum()</code> to calculate which months do not have:</p>
<ul>
<li>Less than 3 M unemployed residents (<code>unemploy &lt; 3000</code>)</li>
</ul></li>
<li><p>Use <code>mean()</code> to calculate the proportion of months that have:</p>
<ul>
<li>Greater than or equal to 3 M residents (<code>unemploy &gt;= 3000</code>)</li>
</ul></li>
</ol>
<p><br>
<br>
<br></p>
</div>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KGdncGxvdDIpICAgICAgIyBMb2FkIGdncGxvdDJcbmhlYWQoZWNvbm9taWNzLCAzKSAgICAjIFByaW50IGZpcnN0IDMgcm93c1xuXG4jIFRvdGFsIG1vbnRocyB3aGVyZSB1bmVtcGxveWVkID4gMzAwMCBLXG5zdW0oZWNvbm9taWNzJF9fXyA+IF9fXylcblxuIyBUb3RhbCBtb250aHMgd2hlcmUgdW5lbXBsb3llZCBub3QgPiAzMDAwIEtcbl9fXyhlY29ub21pY3MkX19fKSAtIHN1bShfX18kdW5lbXBsb3kgPiAzMDAwKVxuXG4jIFBlcmNlbnQgb2YgbW9udGhzIHdoZXJlIHVuZW1wbG95ZWQgMzAwMCBLIG9yIG1vcmVcbl9fXyhfX18kdW5lbXBsb3kgPj0gMzAwMCkifQ==
</div>
<p><br>
<br></p>
</div>
<div id="labels-categorizing-logical-vectors" class="section level2">
<h2><span class="header-section-number">1.3</span> Labels: Categorizing Logical Vectors</h2>
<p>When you create <strong>logical vectors</strong> from conditional statements, we can:</p>
<ul>
<li>Categorize <code>TRUE</code> and <code>FALSE</code> values with labels</li>
<li>More clearly summarize our data by labeling <em>how</em> they satisfy conditions</li>
</ul>
<p><br></p>
<div id="determining-which-rows-match-your-conditions" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Determining Which Rows Match Your Condition(s)</h3>
<p>You can create a new <strong>vector</strong> of row numbers that are <code>TRUE</code> using <code>which()</code>:</p>
<p><em>Which census tracts have more than 1,000 residents in poverty?</em></p>
<pre class="r"><code>impov &lt;- atl$Pop_below_poverty &gt; 1000   # Store logical vector: `impov`

which(impov)                            # Determine row number of TRUE values</code></pre>
<pre><code>##  [1]   8   9  12  13  14  25  26  27  35  38  39  41  43  44  45  46  49
## [18]  58  59  60  67  68  69  70  71  75  76  80  81  83  84  85  87  88
## [35]  89  91  92  93  94  95  98  99 100</code></pre>
<p><br></p>
</div>
<div id="indexing-labeling-rows-that-match-your-conditions" class="section level3">
<h3><span class="header-section-number">1.3.2</span> Indexing &amp; Labeling Rows that Match Your Condition(s)</h3>
<p>By assigning which rows match your conditional statement (using <code>which()</code>):</p>
<ol style="list-style-type: decimal">
<li>You can create an index of rows and assign them to an object</li>
<li>Then, you can operate <em>only on the rows that satisfy your conditions</em></li>
</ol>
<p><br></p>
<p><strong>Indexing Matching Rows:</strong> Use assignment with <code>&lt;-</code> to create an index of rows:</p>
<pre class="r"><code>impov &lt;- atl$Pop_below_poverty &gt; 1000   # Assign logical vector: `impov`

index &lt;- which(impov)                   # Assign row numbers: &quot;index&quot;

print(index)                            # Print row numbers that are TRUE</code></pre>
<pre><code>##  [1]   8   9  12  13  14  25  26  27  35  38  39  41  43  44  45  46  49
## [18]  58  59  60  67  68  69  70  71  75  76  80  81  83  84  85  87  88
## [35]  89  91  92  93  94  95  98  99 100</code></pre>
<p><br></p>
<p><strong>Filter Matching Rows:</strong> Using row numbers assigned to object <code>index</code>, we can <strong>filter</strong>:</p>
<ul>
<li>Rows which return <code>FALSE</code> vis-à-vis our conditions</li>
<li>Rows which return <code>TRUE</code> vis-à-vis our conditions</li>
</ul>
<pre class="r"><code>atl[index, ]            # Keep rows with TRUE (more than 1K in poverty)</code></pre>
<pre><code>## # A tibble: 43 x 4
##    County Area_Name                       Total_Population Pop_below_pover~
##     &lt;dbl&gt; &lt;chr&gt;                                      &lt;dbl&gt;            &lt;dbl&gt;
##  1  13045 Census Tract 9107.02, Carroll ~             8052             1309
##  2  13045 Census Tract 9107.03, Carroll ~             8743             1681
##  3  13057 Census Tract 904, Cherokee Cou~            10088             1937
##  4  13057 Census Tract 906.02, Cherokee ~             7952             1339
##  5  13057 Census Tract 907.01, Cherokee ~            20202             1963
##  6  13067 Census Tract 304.05, Cobb Coun~             6020             1058
##  7  13067 Census Tract 304.13, Cobb Coun~             6215             1675
##  8  13067 Census Tract 311.01, Cobb Coun~             5255             1531
##  9  13089 Census Tract 213.08, DeKalb Co~             4148             1047
## 10  13089 Census Tract 220.04, DeKalb Co~             5794             1131
## # ... with 33 more rows</code></pre>
<pre class="r"><code>atl[-index, ]           # Remove rows with TRUE (less than 1K in poverty)</code></pre>
<pre><code>## # A tibble: 57 x 4
##    County Area_Name                       Total_Population Pop_below_pover~
##     &lt;dbl&gt; &lt;chr&gt;                                      &lt;dbl&gt;            &lt;dbl&gt;
##  1  13013 Census Tract 1801.04, Barrow C~             2032              544
##  2  13013 Census Tract 1801.06, Barrow C~             2773              462
##  3  13013 Census Tract 1803.02, Barrow C~             5434              774
##  4  13013 Census Tract 1805.03, Barrow C~             4960              348
##  5  13015 Census Tract 9603, Bartow Coun~             6714              893
##  6  13015 Census Tract 9604.01, Bartow C~            10043              962
##  7  13015 Census Tract 9604.02, Bartow C~             8758              838
##  8  13045 Census Tract 9108, Carroll Cou~             4188              619
##  9  13045 Census Tract 9110, Carroll Cou~             6083              916
## 10  13057 Census Tract 910.06, Cherokee ~             4951              212
## # ... with 47 more rows</code></pre>
<p><br></p>
<p><strong>Labeling Rows:</strong> Categorize rows by assigning labels to those that match your condition(s).</p>
<ol style="list-style-type: decimal">
<li>First, add a variable of missing (<code>NA</code>) values: i.e. <code>dataframe$new_variable &lt;- NA</code></li>
<li>Next, assign a text string of class “character” to matching rows (<code>TRUE</code>)</li>
<li>Lastly, assign a text string to non-matching rows (<code>FALSE</code>)</li>
</ol>
<pre class="r"><code>atl$poverty_threshold &lt;- NA                   # Initialize variable of all NAs

atl[index, &quot;poverty_threshold&quot;] &lt;- &quot;Over&quot;     # Assign label for rows with TRUE

atl[-index, &quot;poverty_threshold&quot;] &lt;- &quot;Under&quot;   # Assign label for rows with FALSE

head(atl, 10)</code></pre>
<pre><code>## # A tibble: 10 x 5
##    County Area_Name      Total_Population Pop_below_pover~ poverty_thresho~
##     &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;           
##  1  13013 Census Tract ~             2032              544 Under           
##  2  13013 Census Tract ~             2773              462 Under           
##  3  13013 Census Tract ~             5434              774 Under           
##  4  13013 Census Tract ~             4960              348 Under           
##  5  13015 Census Tract ~             6714              893 Under           
##  6  13015 Census Tract ~            10043              962 Under           
##  7  13015 Census Tract ~             8758              838 Under           
##  8  13045 Census Tract ~             8052             1309 Over            
##  9  13045 Census Tract ~             8743             1681 Over            
## 10  13045 Census Tract ~             4188              619 Under</code></pre>
<p><br></p>
<p><strong>If-Else Labeling:</strong> Function <code>ifelse()</code> streamlines condition-based labeling of <strong>logical</strong> output.</p>
<pre class="r"><code>atl$poverty_threshold &lt;- NA                           # Initialize variable of all NAs

label &lt;- ifelse(test = atl$Pop_below_poverty &gt; 1000,  # Specify conditional statement
                yes = &quot;Over&quot;,                         # If TRUE, label &quot;Over&quot;
                no = &quot;Under&quot;)                         # If FALSE, label &quot;under&quot;

atl$poverty_threshold &lt;- label                        # Replace NAs with labels

head(atl, 10)</code></pre>
<pre><code>## # A tibble: 10 x 5
##    County Area_Name      Total_Population Pop_below_pover~ poverty_thresho~
##     &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;           
##  1  13013 Census Tract ~             2032              544 Under           
##  2  13013 Census Tract ~             2773              462 Under           
##  3  13013 Census Tract ~             5434              774 Under           
##  4  13013 Census Tract ~             4960              348 Under           
##  5  13015 Census Tract ~             6714              893 Under           
##  6  13015 Census Tract ~            10043              962 Under           
##  7  13015 Census Tract ~             8758              838 Under           
##  8  13045 Census Tract ~             8052             1309 Over            
##  9  13045 Census Tract ~             8743             1681 Over            
## 10  13045 Census Tract ~             4188              619 Under</code></pre>
<p><br></p>
<p><strong>Categorizing with Multiple Labels:</strong> Multiple labels require multiple conditional statements.</p>
<p>While there are many ways to do this, we’ve broken it down step by step here:</p>
<pre class="r"><code># Initialize a variable of all NA values: &quot;population_size&quot;

atl$population_size &lt;- NA

# Assign multiple indices of row numbers, from multiple conditions, to new objects

sml &lt;- which(atl$Total_Population &lt; 3000)
med &lt;- which(atl$Total_Population &gt;= 3000 &amp; atl$Total_Population &lt; 6000)
lrg &lt;- which(atl$Total_Population &gt;= 6000 &amp; atl$Total_Population &lt; 10000)
wow &lt;- which(atl$Total_Population &gt;= 10000)

# Use each index of row numbers to assign a unique label

atl[sml, &quot;population_size&quot;] &lt;- &quot;Small&quot;
atl[med, &quot;population_size&quot;] &lt;- &quot;Medium&quot;
atl[lrg, &quot;population_size&quot;] &lt;- &quot;Large&quot;
atl[wow, &quot;population_size&quot;] &lt;- &quot;Massive&quot;

# Print first 10 rows

head(atl, 10)</code></pre>
<pre><code>## # A tibble: 10 x 5
##    County Area_Name       Total_Population Pop_below_pover~ population_size
##     &lt;dbl&gt; &lt;chr&gt;                      &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;          
##  1  13013 Census Tract 1~             2032              544 Small          
##  2  13013 Census Tract 1~             2773              462 Small          
##  3  13013 Census Tract 1~             5434              774 Medium         
##  4  13013 Census Tract 1~             4960              348 Medium         
##  5  13015 Census Tract 9~             6714              893 Large          
##  6  13015 Census Tract 9~            10043              962 Massive        
##  7  13015 Census Tract 9~             8758              838 Large          
##  8  13045 Census Tract 9~             8052             1309 Large          
##  9  13045 Census Tract 9~             8743             1681 Large          
## 10  13045 Census Tract 9~             4188              619 Medium</code></pre>
<p><br>
<br></p>
</div>
</div>
<div id="logical-vectors-non-numeric-conditionals" class="section level2">
<h2><span class="header-section-number">1.4</span> Logical Vectors &amp; Non-Numeric Conditionals</h2>
<p><strong>Logical</strong> vectors result from any conditional statement, even if not quantitative.</p>
<p>Below are a few use cases for <strong>logical</strong> values based on non-numeric conditions.</p>
<p>These data come from <a href="https://data.cityofnewyork.us/Transportation/Medallion-Drivers-Active/jb3k-j3gp/data">New York City’s medallian-authorized cab drivers</a>.</p>
<pre class="r"><code>library(readr)
library(dplyr)
library(lubridate)

url &lt;- paste0(&quot;https://data.cityofnewyork.us/api/views&quot;,
              &quot;/jb3k-j3gp/rows.csv?accessType=DOWNLOAD&quot;)    # Assign URL

taxi &lt;- read_csv(url) %&gt;%                                   # Read in 1,000 rows
  mutate(`Expiration Date` = mdy(`Expiration Date`),
         `Last Date Updated` = mdy(`Last Date Updated`),
         `Last Time Updated` = hms(`Last Time Updated`))    # Convert dates, times</code></pre>
<p><br></p>
<p><strong>Date-Based Conditions:</strong> Let’s extract medallians expiring on <a href="https://en.wikipedia.org/wiki/Palindrome">palindrome</a> 2020-02-02:</p>
<pre class="r"><code>index &lt;- which( taxi$`Expiration Date` == &quot;2020-02-02&quot;)   # Index rows where TRUE

palindrome &lt;- taxi[index, ]                               # Filter by indexed rows

head(palindrome)</code></pre>
<pre><code>## # A tibble: 6 x 6
##   `License Number` Name  Type  `Expiration Dat~ `Last Date Upda~
##              &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt;           &lt;date&gt;          
## 1           662602 CHAU~ MEDA~ 2020-02-02       2019-09-29      
## 2           692710 TEJA~ MEDA~ 2020-02-02       2019-09-29      
## 3           678010 XU,C~ MEDA~ 2020-02-02       2019-09-29      
## 4           678820 LIRA~ MEDA~ 2020-02-02       2019-09-29      
## 5           695806 CHEK~ MEDA~ 2020-02-02       2019-09-29      
## 6           677474 ESPI~ MEDA~ 2020-02-02       2019-09-29      
## # ... with 1 more variable: `Last Time Updated` &lt;S4: Period&gt;</code></pre>
<p><br></p>
<p><strong>Date Unit-Based Conditions:</strong> Here, we use function <code>year()</code> from package <em>lubridate</em>:</p>
<ul>
<li>Function <code>year()</code> extracts the year from date objects</li>
<li>Our logical statement returns <code>TRUE</code> if <code>year()</code> returns “2021”</li>
<li>Function <code>sum()</code> is used to tally all medallians expiring in 2021</li>
<li>Function <code>mean()</code> is used to calculate the percent of 2021 expirations</li>
</ul>
<pre class="r"><code>library(lubridate)

expire_21 &lt;- year(taxi$`Expiration Date`) == 2021     # TRUE if expires in 2021

sum(expire_21)                                        # Sum of 2021 expirations</code></pre>
<pre><code>## [1] 37152</code></pre>
<pre class="r"><code>mean(expire_21)                                       # Percent of 2021 expirations</code></pre>
<pre><code>## [1] 0.2007912</code></pre>
<p><br></p>
<p><strong>Text-Based Conditions</strong>: Use core R function <code>grepl()</code> for conditional pattern-matching.</p>
<ul>
<li>The ‘l’ in ‘grepl()’ stands for “logical” - it’s designed to output <strong>logical</strong> values!</li>
<li>Here, we’ll search for all records beginning with common Indian surname “Singh”</li>
<li>The pattern matching method is called “regular expressions”
<ul>
<li><code>^</code> indicates that the pattern is at the beginning of the string</li>
<li><code>.</code> indicates “any character” and <code>*</code> indicates “any number of times”</li>
<li>Therefore, we only retrieve records that begin with <code>Singh</code></li>
</ul></li>
</ul>
<pre class="r"><code>surname_match &lt;- grepl(pattern = &quot;^SINGH.*&quot;,    # Regular expressions pattern  
                       x = taxi$Name)           # Specify dataset and variable

head(surname_match, 10)                         # Return first 10 TRUE or FALSE</code></pre>
<pre><code>##  [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>sum(surname_match)                              # Total TRUE</code></pre>
<pre><code>## [1] 7516</code></pre>
<pre class="r"><code>mean(surname_match)                             # Percent TRUE</code></pre>
<pre><code>## [1] 0.04062088</code></pre>
<p><br></p>
<p>Compare these results to the most common Indian surname in London: “Patel”. Wow!</p>
<pre class="r"><code>surname_match &lt;- grepl(pattern = &quot;^PATEL.*&quot;,    # Regular expressions pattern  
                       x = taxi$Name)           # Specify dataset and variable

head(surname_match, 10)                         # Return first 10 TRUE or FALSE</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>sum(surname_match)                              # Total TRUE</code></pre>
<pre><code>## [1] 92</code></pre>
<pre class="r"><code>mean(surname_match)                             # Percent TRUE</code></pre>
<pre><code>## [1] 0.000497222</code></pre>
<p><br></p>
<p><strong>Conditions with Missing Values:</strong> It’s very common to condition on missing values (<code>NA</code>).</p>
<ul>
<li>Function <code>is.na()</code> returns a <strong>logical</strong> vector of <code>TRUE</code> or <code>FALSE</code></li>
<li>This is similar to any <code>is.*()</code> function, all of which return <strong>logical</strong> values</li>
<li>Since these data have no missing data, remove all drivers with surname “Singh”</li>
</ul>
<pre class="r"><code>index &lt;- grepl(pattern = &quot;^SINGH.*&quot;,    # Regular expressions pattern  
               x = taxi$Name)           # Specify dataset and variable

taxi[index, &quot;Name&quot;] &lt;- NA               # Remove names

missing &lt;- is.na(taxi$Name)             # Detect, store missing values

sum(missing)                            # Total NA values in vector</code></pre>
<pre><code>## [1] 7516</code></pre>
<p><br></p>
<p><strong>Detecting Incomplete Records:</strong> Function <code>complete.cases()</code>:</p>
<ul>
<li>Like <code>grepl()</code> or <code>is.na()</code> functions, always returns <strong>logical</strong> vector</li>
<li>Any row containing one or more <code>NA</code> value will return <code>FALSE</code></li>
<li>Used on entire data frames and checks all variables</li>
</ul>
<p>Dataset <code>taxi</code> is incomplete; we detect how many of the first 100 rows have an <code>NA</code>:</p>
<pre class="r"><code>complete.cases(taxi[1:100, ])           # Check for NAs in first 100 rows</code></pre>
<pre><code>##   [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [23]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [34] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [45]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [56]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [67]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [78]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [89]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [100]  TRUE</code></pre>
<pre class="r"><code>sum(complete.cases(taxi[1:100, ]))      # How many don&#39;t have NA values?</code></pre>
<pre><code>## [1] 95</code></pre>
<p><br></p>
<p><strong>Conclusions:</strong> Class <strong>logical</strong> vectors are extremely common in exploratory data analyses and its use cases are many and varied. We use them for labeling, filtering, control flow structures, detection, etc. You’re now equipped to use <strong>logical</strong> output for the same ends, and mastering this data class is fundamental for basic fluency in R.</p>
<p>Future chapters will be no stranger to the basic techniques described above, so come back and visit!</p>
<p><br>
<br></p>
</div>
<div id="further-resources" class="section level2">
<h2><span class="header-section-number">1.5</span> Further Resources</h2>
<ul>
<li><a href="http://rpubs.com/JamisonCrawford/operators">Intro to R: Operators</a> (Crawford, 2018): See <em>Section 6.1: Filtering with Logic</em></li>
<li><a href="http://rpubs.com/JamisonCrawford/subsets">Intro to R: Subsets &amp; Indices</a> (Crawford, 2018): See <em>Section 6.4: Conditional Subsetting</em></li>
</ul>
</div>
</div>

<div class="footer">
<div class="row"  align="center">

  Notes for the <a href=http://ds4ps.org/ms-prog-eval-data-analytics/ target="_blank">MS in Program Evaluation and Data Analytics</a><br>
  A program at <a href=https://asuonline.asu.edu/online-degree-programs/graduate/program-evaluation-and-data-analytics-ms/ target="_blank">Arizona State University</a><br>
  Website powered by <a href=https://rmarkdown.rstudio.com/ target="_blank">R Markdown</a> and <a href=http://jekyllrb.com target="_blank">Jekyll</a>

<br>
<br>

</div>
</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
